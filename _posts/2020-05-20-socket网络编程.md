---
layout: post
title:  socket网络编程
subtitle: 套接字、listen()和accept()等
author: zql
date: 2020-05-20
header-img: img/network_post.jpg
catalog:  true
tags:
    - 计算机网络
---
### 目录  
 - tcp socket编程
 - udp socket编程
 - listen()队列
 - accept()函数
 
**套接字(socket)：**就是个数字，通过调用socket()函数来生成，这个数字具有唯一性,直到你调用close()函数把这个数字关闭。  
文件描述符；一切皆文件，可以把socket也看成是文件描述符，我们可以用socket来收发数据；send(),recv()。  
服务器端首先创建一个socket用于与客户端连接，建立连接之后accept()返回一个套接字用于与客户端收发数据。  
### tcp socket网络编程  
TCP编程的服务器端一般步骤是:   
1.创建一个socket，用函数socket()   
2.设置socket属性，用函数setsockopt(); * 可选  
3.绑定IP地址、端口等信息到socket上，用函数bind()   
4.开启监听，用函数listen()  
5.接收客户端上来的连接，用函数accept()  
6.收发数据，用函数send()和recv()，或者read()和write()   
7.关闭网络连接   
8.关闭监听   
![avatar](/img/tcpsocket_post.png)  
TCP编程的客户端一般步骤是:  
1.创建一个socket，用函数socket()  
2.设置socket属性，用函数setsockopt();* 可选  
3.绑定IP地址、端口等信息到socket上，用函数bind();* 可选  
4.设置要连接的对方的IP地址和端口等属性   
5.连接服务器，用函数connect()  
6.收发数据，用函数send()和recv()，或者read()和write()   
7.关闭网络连接  
### udp socket网络编程  
UDP编程的服务器端一般步骤是:  
1.创建一个socket，用函数socket()  
2.设置socket属性，用函数setsockopt();* 可选   
3.绑定IP地址、端口等信息到socket上，用函数bind()  
4.循环接收数据，用函数recvfrom()   
5.关闭网络连接  
UDP编程的客户端一般步骤是:  
1.创建一个socket，用函数socket()  
2.设置socket属性，用函数setsockopt();* 可选   
3.绑定IP地址、端口等信息到socket上，用函数bind();* 可选   
4.设置对方的IP地址和端口等属性  
5.发送数据，用函数sendto()  
6.关闭网络连接  
![avatar](/img/udpsocket_post.png)  
### listen()队列  
listen()：监听端口，用在TCP连接中的服务器端角色  
listen()函数调用格式:int listen(int sockfd, int backlog)  
backlog曾经的含义：已完成队列和未完成队列里边条目之和不能超过backlog  
backlog进一步明确和规定了：指定给定套接字上内核为之排队的最大已完成连接数[已完成连接队列中最大条目数]
监听套接字的队列:对于一个调用listen()进行监听的套接字，操作系统会给这个套接字维护两个队列。  
1.未完成连接队列[保存连接用的]  
当客户端发送tcp连接三次握手的第一次[syn包]给服务器的时候，服务器就会在未完成队列中创建一个跟这个syn包对应的一项。
其实，我们可以把这项看成是一个半连接，这个半连接的状态会从LISTEN变成SYN_RCVD状态，同时给客户端返回第二次握手包[syn,ack]。这个时候，服务器在等待完成第三次握手。  
2.已完成连接队列[保存连接用的]  
当第三次握手完成了，这个连接就变成了ESTABLISHED状态，每个已经完成三次握手的客户端都放在这个队列中作为一项。  
客户端这个connect()什么时候返回，其实是收到三次握手的第二次握手包（也就是收到服务器发回来的syn/ack）之后就返回了。  
RTT是未完成队列中任意一项在未完成队列中留存的时间，这个时间取决于客户端和服务器:对于客户端，这个RTT时间是第一次和第二次握手加起来的时间;对于服务器，这个RTT时间实际上是第二次和第三次握手加起来的时间。  
### accept()函数  
accept()函数，就使用来从已完成连接队列中的队首位置取出来一项(每一项都是一个已经完成三路握手的TCP连接)，返回给进程。  
如果已完成连接队列是空的呢？accept()会一致卡在这里休眠等待，一直到已完成队列中有一项时才会被唤醒。所以，从编程角度，我们要尽快的用accept()把已完成队列中的数据[TCP连接]取走。  
accept()返回的是个套接字，这个套接字就代表那个已经用三次握手建立起来的那个tcp连接，因为accept()是从已完成队列中取的数据。换句话来说，服务器程序必须要严格区分两个套接字:  
1.监听端口套接字，这个东西叫“监听套接字[listenfd]”，只要服务器程序在运行，这个套接字就应该一直存在。  
2.当客户端连接进来，操作系统会为每个成功建立三次握手的客端再创建一个套接字[当然是一个已经连接套接字]，accept()返回的就是这种套接字。也就是从已完成连接队列中取得的一项。随后，服务器使用这个accept()返回的套接字和客户端通信。  
**思考：**  
1.如果两个队列之和[已完成连接队列，和未完成连接队列]达到了listen()所指定的第二参数，也就是说队列满了，此时，再有一个客户发送syn请求，服务器怎么反应？  
实际上服务器会忽略这个syn，不给回应；客户端这边，发现syn没回应，过一会会重发syn包。  
2.从连接被扔到已经完成队列中去，到accept()从已完成队列中把这个连接取出这个之间是有个时间差的，如果还没等accept()从已完成队列中把这个连接取走的时候，客户端发送来数据，这个数据就会被保存再已经连接的套接字的接收缓冲区里，这个缓冲区有多大，最大就能接收多少数据量。  
