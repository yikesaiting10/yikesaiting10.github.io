---
layout:   post
title:    C++基础
subtitle:   面试常考
author:   zql
date:   2020-04-23
header-img:   img/gakki_smile_white2.jpg
catalog:    true
tags:
    - C++
---
## 目录
- 面向对象的基本特征
- 指针和引用的区别
- static关键字
- const关键字
- 虚函数

### 面向对象的基本特征
**1.封装**  
    封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。  
**2.继承**  
    继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。  
**3.多态**  
    多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。  
### 指针和引用的区别  
  引用声明时必须指向一个实例的对象，指针可以初始化为null  
  引用没有自己的内存空间，指针拥有自己的内存空间  
  sizeof引用指所引对象的大小，sizeof指是指针本身的大小  
  引用和指针进行++操作的结果不同  
  引用不可更改引用的对象，指针可以更改指向的对象  
  没有多级引用，可以有多级指针(** p)  
  作为参数传递时，可以直接对引用修改以改变对象，指针需要解引用才可对对象进行修改  
### malloc和new的区别  
**1.申请的内存所在位置**  
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。  
**2.返回类型安全性**  
操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void* 指针转换成我们需要的类型。  
**3.内存分配失败时的返回值**  
new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。  
**4.是否需要指定内存大小**  
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。  
**5.是否调用构造函数/析构函数**  
使用new操作符来分配对象内存时会经历三个步骤：  
第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。  
第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。  
第三步：对象构造完成后，返回一个指向该对象的指针。  
使用delete操作符来释放对象内存时会经历两个步骤：  
第一步：调用对象的析构函数。  
第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。  
### static关键字  
**1.全局静态变量**  
  在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。  
  内存中的位置：静态存储区，在整个程序运行期间一直存在。  
  初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；  
  域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。  
**2.局部静态变量**  
  在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。  
  内存中的位置：静态存储区  
  初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；  
  作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，   只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；  
**3.静态函数**  
  在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。  
  函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；  
  warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；  
**4.类的静态成员**  
  在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。  
**5.类的静态函数**  
  成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。  
  在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>)  
### const关键字  
  const修饰常变量，不可赋值。  
  const修饰指针，将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符      * const。  
  const修饰函数传入参数，调用函数不可修改该对象的值，将指针参数声明为const，函数不可修改指向的对象。  
  const修饰函数返回值，用户不可修改返回值，返回值应赋给常量或常指针。  
  const修饰成员函数，const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的。  
  const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。  
### 虚函数  
  c++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。  
  虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中。
  当子类调用虚函数时通过虚函数表找到对应的虚函数地址，使用子类定义的虚函数。  
  一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual,也能实现多态。
### 未完待续
