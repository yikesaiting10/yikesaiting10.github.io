---
layout:   post
title:    C++基础
subtitle:   面试常考
author:   zql
date:   2020-04-23
header-img:   img/gakki_smile_white2.jpg
catalog:    true
tags:
    - C++
---
## 目录
- 面向对象的基本特征
- 指针和引用的区别
- static关键字
- const关键字
- explicit关键字
- 虚函数
- 内联函数
- 类型转换
- 智能指针    
### 面向对象的基本特征
**1.封装**  
    封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。  
**2.继承**  
    继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。  
**3.多态**  
    多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。  
### 指针和引用的区别  
  引用声明时必须指向一个实例的对象，指针可以初始化为null  
  引用没有自己的内存空间，指针拥有自己的内存空间  
  sizeof引用指所引对象的大小，sizeof指是指针本身的大小  
  引用和指针进行++操作的结果不同  
  引用不可更改引用的对象，指针可以更改指向的对象  
  没有多级引用，可以有多级指针(** p)  
  作为参数传递时，可以直接对引用修改以改变对象，指针需要解引用才可对对象进行修改  
### malloc和new的区别  
**1.申请的内存所在位置**  
new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。  
**2.返回类型安全性**  
操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void* 指针转换成我们需要的类型。  
**3.内存分配失败时的返回值**  
new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。  
**4.是否需要指定内存大小**  
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。  
**5.是否调用构造函数/析构函数**  
使用new操作符来分配对象内存时会经历三个步骤：  
第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。  
第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。  
第三步：对象构造完成后，返回一个指向该对象的指针。  
使用delete操作符来释放对象内存时会经历两个步骤：  
第一步：调用对象的析构函数。  
第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。  
### static关键字  
**1.全局静态变量**  
  在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。  
  内存中的位置：静态存储区，在整个程序运行期间一直存在。  
  初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；  
  域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。  
**2.局部静态变量**  
  在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。  
  内存中的位置：静态存储区  
  初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；  
  作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，   只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；  
**3.静态函数**  
  在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。  
  函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；  
  warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；  
**4.类的静态成员**  
  在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。  
**5.类的静态函数**  
  成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。  
  在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>)  
### const关键字  
  const修饰常变量，不可赋值。  
  const修饰指针，将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符      * const。  
  const修饰函数传入参数，调用函数不可修改该对象的值，将指针参数声明为const，函数不可修改指向的对象。  
  const修饰函数返回值，用户不可修改返回值，返回值应赋给常量或常指针。  
  const修饰成员函数，const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的。  
  const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。  
### explicit关键字  
C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式)。  
explicit关键字的作用就是防止类构造函数的隐式自动转换，explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了。当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数。  
[参考](https://www.cnblogs.com/rednodel/p/9299251.html)  
### 虚函数  
  c++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。  
  
  虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中。当子类调用虚函数时通过虚函数表找到对应的虚函数地址，使用子类定义的虚函数。  
  
  一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual,也能实现多态。  
  如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。

  如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。

如果类中成员是virtual属性，会隐藏父类对应的属性。  
![avatar](/img/virtual_post.png)  
### 内联函数  
C++内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。  
C++中支持内联函数，其目的是为了提高函数的执行效率，用关键字 inline 放在函数定义(注意是定义而非声明)的前面即可将函数指定为内联函数，关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：  
```
inline int max(int a, int b)
{
    return a > b ? a : b;
}
```
则调用：cout << max(a, b) << endl;  
在编译时展开为：cout << (a > b ? a : b) << endl; 从而消除了把 max写成函数的额外执行开销。  
对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。  
在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。  
内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。
当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。  
![avatar](/img/inline_post.jpg)  
**与宏的区别**  
内联函数的执行过程与带参数宏定义很相似，但参数的处理不同。带参数的宏定义并不对参数进行运算，而是直接替换；内联函数首先是函数，这就意味着函数的很多性质都适用于内联函数，即内联函数先把参数表达式进行运算求值，然后把表达式的值传递给形式参数。  
内联函数与带参数宏定义的另一个区别是，内联函数的参数类型和返回值类型在声明中都有明确的指定；而带参数宏定义的参数没有类型的概念，只有在宏展开以后，才由编译器检查语法，这就存在很多的安全隐患。  
### 类型转换  
C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast
1、const_cast
用于将const变量转为非const
2、static_cast
用于各种隐式转换，比如非const转const，void* 转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
3、dynamic_cast
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
向上转换：指的是子类向基类的转换
向下转换：指的是基类向子类的转换
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
4、reinterpret_cast
几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
5、为什么不使用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。  
### 智能指针  
C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。  
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。   
1.unique_ptr（替换auto_ptr）  
unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。  
2.shared_ptr  
shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。  
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。  
3.weak_ptr  
weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。  
### 未完待续
