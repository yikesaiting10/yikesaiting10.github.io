---
layout: post
title:  Mysql
subtitle: 约束、索引、回表等
author: zql
date: 2020-05-12
header-img: img/database_post.jpg
catalog:  true
tags:
    - 数据库
---  

### 目录  
 - 约束
 - 索引
 - 回表
### 约束  
#### 1.什么是约束  
约束英文：constraint  
约束实际上就是表中数据的限制条件  
#### 2.约束作用  
表在设计的时候加入约束的目的就是为了保证表中的记录完整和有效  
比如name字段中要让其用户名不重复，这就需要添加约束。或者必须注册的时候需要添加邮箱等  
#### 3.约束种类  
**非空约束(not null)：**  
用not null约束的字段不能为null值，必须给定具体的数据。  
**唯一性约束(unique)：**  
unique约束的字段，具有唯一性，不可重复，但可以为null。联合约束，表示两个或以上的字段同时与另一条记录相等，则报错。  
**主键约束(primary key) PK：**  
表设计时一定要有主键。  
1、主键涉及术语  
主键约束  
主键字段  
主键值  
2、以上三种术语关系  
表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值。  
3、主键约束与“not null unique”区别  
给某个字段添加主键约束之后，该字段不能重复也不能为空，效果和”not null unique”约束相同，但是本质不同。  
主键约束除了可以做到”not null unique”之外，还会默认添加”索引——index”。  
4、一张表应该有主键字段，如果没有，表示该表无效  
主键值：是当前行数据的唯一标识、是当前行数据的身份证号。  
即使表中两行记录相关数据相同，但由于主键值不同，所以也认为是两行不同的记录。  
5、按主键约束的字段数量分类  
无论是单一主键还是复合主键，一张表主键约束只能有一个(约束只能有一个，但可以作用到好几个字段)。  
单一主键：给一个字段添加主键约束。  
复合主键：给多个字段联合添加一个主键约束(只能用表级定义)。  
**外键约束(foreign key) FK：**  
只能是表级定义。  
什么是外键：若有两个表A、B，id是A的主键，而B中也有id字段，则id就是表B的外键，外键约束主要用来维护两个表之间数据的一致性，A为基本表，B为信息表。  
1、外键涉及到的术语  
外键约束  
外键字段  
外键值  
2、外键约束、外键字段、外键值之间的关系  
某个字段添加外键约束之后，该字段称为外键字段，外键字段中每个数据都是外键值。  
3、按外键约束的字段数量分类  
单一外键：给一个字段添加外键约束  
复合外键：给多个字段联合添加一个外键约束  
4、一张表可以有多个外键字段（与主键不同）  
**检查约束(目前MySQL不支持、Oracle支持)**  
[来源](https://blog.csdn.net/w_linux/article/details/79655073)  
### 索引  
#### 索引存储  
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。  
#### B+树分析  
B树的搜索复杂度为O(h)=O(logdN)，所以树的出度d越大，深度h就越小，I/O的次数就越少。B+Tree恰恰可以增加出度d的宽度，因为每个节点大小为一个页大小，所以出度的上限取决于节点内key和data的大小：
dmax=floor(pagesize/(keysize+datasize+pointsize))//floor表示向下取整  
由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，从而拥有更好的性能。  
![avatar](http://img.blog.csdn.net/20160926141127260)  
B-树和B+树查找过程基本一致。如上图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。  
#### 索引的实现  
**MyISAM索引实现**    
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：  
![avatar](http://img.blog.csdn.net/20160926141231996)  
这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：  
![avatar](http://img.blog.csdn.net/20160926141811354)  
同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。  
MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。  
**InnoDB索引实现**  
虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。  
第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。  
![avatar](http://img.blog.csdn.net/20160926141856136)  
上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。  
第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：  
![avatar](http://img.blog.csdn.net/20160926141926745)  
这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。  
了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。  
#### 索引优化  
**合索引及最左前缀原理**  
**联合索引（复合索引）**  
首先介绍一下联合索引。联合索引其实很简单，相对于一般索引只有一个字段，联合索引可以为多个字段创建一个索引。它的原理也很简单，比如，我们在（a,b,c）字段上创建一个联合索引，则索引记录会首先按照A字段排序，然后再按照B字段排序然后再是C字段，因此，联合索引的特点就是：  
第一个字段一定是有序的。  
当第一个字段值相等的时候，第二个字段又是有序的，比如下表中当A=2时所有B的值是有序排列的，依次类推，当同一个B值得所有C字段是有序排列的。  
```
| A | B | C | 
| 1 | 2 | 3 | 
| 1 | 4 | 2 | 
| 1 | 1 | 4 | 
| 2 | 3 | 5 | 
| 2 | 4 | 4 | 
| 2 | 4 | 6 | 
| 2 | 5 | 5 |
```
其实联合索引的查找就跟查字典是一样的，先根据第一个字母查，然后再根据第二个字母查，或者只根据第一个字母查，但是不能跳过第一个字母从第二个字母开始查。这就是所谓的最左前缀原理。  
**最左前缀原理**  
我们再来详细介绍一下联合索引的查询。还是上面例子，我们在（a,b,c）字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的，所以：  
以下的查询方式都可以用到索引：  
select * from table where a=1；  
select * from table where a=1 and b=2；  
select * from table where a=1 and b=2 and c=3；  
上面三个查询按照 （a ）, （a，b ）,（a，b，c ）的顺序都可以利用到索引，这就是最左前缀匹配。  
如果查询语句是：  
select * from table where a=1 and c=3； 那么只会用到索引a。  
如果查询语句是：  
select * from table where b=2 and c=3； 因为没有用到最左前缀a，所以这个查询是用户到索引的。  
如果用到了最左前缀，但是顺序颠倒会用到索引码？  
比如：  
select * from table where b=2 and a=1；  
select * from table where b=2 and a=1 and c=3；  
如果用到了最左前缀而只是颠倒了顺序，也是可以用到索引的，因为mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。但我们还是最好按照索引顺序来查询，这样查询优化器就不用重新编译了。  
**前缀索引**  
除了联合索引之外，对mysql来说其实还有一种前缀索引。前缀索引就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。  
一般来说以下情况可以使用前缀索引：  
字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’  
字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。  
前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。  
一些文章中也提到：  
MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)。  
**索引优化策略**  
最左前缀匹配原则，上面讲到了  
主键外检一定要建索引  
对 where,on,group by,order by 中出现的列使用索引  
尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0  
对较小的数据列使用索引,这样会使索引文件更小,同时内存中也可以装载更多的索引键  
索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);  
为较长的字符串使用前缀索引  
尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可  
不要过多创建索引, 权衡索引个数与DML之间关系，DML也就是插入、删除数据操作。这里需要权衡一个问题，建立索引的目的是为了提高查询效率的，但建立的索引过多，会影响插入、删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建  
对于like查询，”%”不要放在前面。   
SELECT * FROMhoudunwangWHEREunameLIKE'后盾%' -- 走索引  
SELECT * FROMhoudunwangWHEREunameLIKE "%后盾%" -- 不走索引  
查询where条件数据类型不匹配也无法使用索引   
字符串与数字比较不使用索引   
CREATE TABLEa(achar(10))  
EXPLAIN SELECT * FROMaWHEREa="1" – 走索引   
EXPLAIN SELECT * FROM a WHERE a=1 – 不走索引  
[来源](https://www.cnblogs.com/wuchanming/p/6886020.html)  
### 回表  
如果索引的列在select所需获得列中就不需要回表（因为在mysql中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值），如果select所需获得列中有非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。简单来说，通过索引访问得到表的ROWID，然后根据这些ROWID再去访问表中数据行。  
例子：  
```
create table test( name char(5), id int);
create index id_test on test(id);
```
如果这时查询语句是：  
```
select max(id) from test;
```
因为id_test上有关于id的信息，所以只要对索引进行查询就可以了，不用再根据ROWID查询TEST。如果查询  
```
select name from test where id= 200;
```
那根据索引查询到ID为200的rowid后，根据rowid指向的数据，回查到TEST获得相应的NAME。  
