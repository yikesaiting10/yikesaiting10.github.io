---
layout:   post
title:    剑指offer
subtitle:   不定期更新
header-img:   img/others_post.jpg
author:   zql
date:   2020-04-24
catalog:    true
tags:
    - 算法
    - 栈
    - 队列
    - 链表
    - 二叉树
---
### 目录  
 - 用两个栈实现队列
 - 用两个队列实现栈
 - 两个链表的第一个公共结点
 - 二叉搜索树与双向链表  

### 用两个栈实现队列
**题目描述**  
用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型。  
```c++
class solution
{
public:
	void push(int node)
    {
        s1.push(node);
    }
    int pop()
    {
        int res;
        if(s2.empty())
        {
            while(!s1.empty())
            {
                int temp = s1.top();
                s2.push(temp);
                s1.pop();
            }
        }
		res = s2.top();
        s2.pop();
        return res;
    }
private:
    stack<int> s1;
    stack<int> s2;
}
```
### 用两个队列实现栈  
**题目描述**  
用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型。（扩展）  
```c++
class solution
{
 public:
    void push()
    {
        q1.push();
    }
    int top()
    {	
        if(!q1.empty())
        	return q1.back();
        else
            return q2.back();
    }
    int pop()
    {
        int res;
        if(!q1.empty())
        {
            int n = q1.size();
            while(n>1)
    		{
            	q2.push(q1.front());
            	q1.pop();
            	n--;
        	}
            res = q1.front();
            q1.pop();
        }
        else
        {
            int n = q2.size();
            while(n>1)
    		{
            	q1.push(q2.front());
            	q2.pop();
            	n--;
        	}
            res = q2.front();
            q2.pop();
        }
        return res;
    }
private:
    queue<int> q1;
    queue<int> q2;
}
```  
### 两个链表的第一个公共结点  
**题目描述**  
输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）  
```c++
ListNode* firstCommonNode(ListNode* pHead1, ListNode* pHead2)
{
    if(!pHead1 || !pHead2)
        return NULL;
    ListNode* l1 = pHead1;
    ListNode* l2 = pHead2;
    while(l1 != l2)
    {
        l1 = l1->next;
        l2 = l2->next;
        if(l1 != l2) //避免没有公共结点而陷入死循环
        {
            if(!l1)
            	l1 = pHead2;
        	if(!l2)
            	l2 = pHead1;
        }
    }
    return l1;
}
```
### 二叉搜索树与双向链表  
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。  
```c++
TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(!pRootOfTree)
            return NULL;
        TreeNode* l = Convert(pRootOfTree->left);
        if(l)
        {
            TreeNode* l_ = l;
            while(l_ && l_->right)
            {
                l_ = l_->right;
            }
                l_->right = pRootOfTree;
                pRootOfTree->left = l_;
        }
        TreeNode* r = Convert(pRootOfTree->right);
        if(r)
        {
            pRootOfTree->right = r;
            r->left = pRootOfTree;
        }
        return l ? l : pRootOfTree;
    }
```
