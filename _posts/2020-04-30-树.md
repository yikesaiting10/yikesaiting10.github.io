---
layout:  post
title:  树
subtitle:  平衡二叉树、红黑树和B+树
header-img:	 img/datastruct_post.png
author:	 zql
date:	2020-04-30
catalog:	true
tags:	
  - 数据结构
  - 树
---  
### 目录  
 - 平衡二叉树
 - 红黑树  
 - B+树  

### 平衡二叉树  
平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：以树中所有结点为根的树的左右子树高度之差的绝对值不超过1。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。  
**节点定义**  
```c++
struct TreeNode
{
    int val;
    TreeNode* left;
    TreeNode* right;
    int height;
    TreeNode(int v = 0, int h = -1) : val(x), left(NULL), right(NULL), height(h);
}
```
**节点的高度**  
```c++
int treeHeight(TreeNode* a)
{
    return NULL ? -1 : a->height; //空节点高度定位-1，单个节点高度定位0
}
```
**LL旋转：**由于在A的左孩子B的左子树上插入结点F，使A的平衡因子由1增至2而失去平衡。故需进行一次顺时针旋转操作。 即将A的左孩子B向右上旋转代替A作为根结点，A向右下旋转成为B的右子树的根结点。而原来B的右子树则变成A的左子树。  
![avatar](/img/AVL_LL_post.png)    
```c++
void LLRotate(TreeNode* a)
{
    TreeNode* b = a->left;
    a->left = b->right; //b的右子树作为a的左子树
    b->right = a; //a作为b的右子树
    //更新高度
    a->height = max(treeHeight(a->left), treeHeight(a->right));
    b->height = max(treeHeight(b->left), treeHeight(b->right));
    //返回新的根节点，b为局部变量离开作用域自动销毁
    a = b;
}
```
**RR旋转：**由于在A的右孩子C 的右子树上插入结点F，使A的平衡因子由-1减至-2而失去平衡。故需进行一次逆时针旋转操作。即将A的右孩子C向左上旋转代替A作为根结点，A向左下旋转成为C的左子树的根结点。而原来C的左子树则变成A的右子树。  
![avatar](/img/AVL_RR_post.png)  
```c++
void RRRotate(TreeNode* a)
{
    TreeNode* c = a->right;
    a->right = c->left; //c的左子树作为a的右子树
    c->left = a; //a作为c的左子树
    //更新高度
    a->height = max(treeHeight(a->left), treeHeight(a->right));
    c->height = max(treeHeight(c->left), treeHeight(c->right));
    //返回新的根节点，c为局部变量离开作用域自动销毁
    a = c;
}
```
**LR旋转：**由于在A的左孩子B的右子数上插入结点F，使A的平衡因子由1增至2而失去平衡。故需进行两次旋转操作（先逆时针，后顺时针）。即先将A结点的左孩子B的右子树的根结点D向左上旋转提升到B结点的位置，然后再把该D结点向右上旋转提升到A结点的位置。即先使之成为LL型，再按LL型处理。  
![avatar](/img/AVL_LR_post.png)  
```c++
void LRRotate(TreeNode* a)
{
    //先进行RR旋转
    TreeNode* b = a->left;
    RRRotate(b);
    //在进行LL旋转
    LLRotate(a);
    //更新高度
    a->height = max(treeHeight(a->left), treeHeight(a->right));
    b->height = max(treeHeight(b->left), treeHeight(b->right));
}
```
**RL旋转：**由于在A的右孩子C的左子树上插入结点F，使A的平衡因子由-1减至-2而失去平衡。故需进行两次旋转操作（先顺时针，后逆时针），即先将A结点的右孩子C的左子树的根结点D向右上旋转提升到C结点的位置，然后再把该D结点向左上旋转提升到A结点的位置。即先使之成为RR型，再按RR型处理。  
![avatar](/img/AVL_RL_post.png)  
```c++
void RLRotate(TreeNode* a)
{
    //先进行LL旋转
    TreeNode* c = a->right;
    LLRotate(c);
   	//再进行RR旋转
    RRRotate(a);
    //更新高度
    a->height = max(treeHeight(a->left), treeHeight(a->right));
    c->height = max(treeHeight(c->left), treeHeight(c->right));
}
```
**平衡二叉树的性能优势：**  
很显然，平衡二叉树的优势在于不会出现普通二叉查找树的最差情况。其查找的时间复杂度为O(logN)。  
**平衡二叉树的缺陷：**  
很遗憾的是，为了保证高度平衡，动态插入和删除的代价也随之增加。红黑树是更加高效的查找结构。  
[插入、删除、查找实现参考](https://blog.csdn.net/lpp0900320123/article/details/39367451?utm_source=app)  
### 红黑树  
红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。  
性质：  
1. 每个节点非红即黑;  
2. 根节点是黑的;  
3. 每个叶节点（叶节点即树尾端NULL指针或NULL节点）都是黑的;  
4. 如果一个节点是红色的，则它的子节点必须是黑色的;  
5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点;  
从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在**O(logn)**时间内做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保持为 O(log n) 次。  
**红黑树较AVL树的优点：**  
AVL树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，**插入最多两次旋转，删除最多三次旋转。**    
所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。  
**红黑树旋转：**  
**旋转：**红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质。  
**左旋：**对某个结点x做左旋操作时，假设其右孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子。  
![avatar](/img/rbtree_lr_post.png)  
**右旋：**对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子。  
![avatar](//img/rbtree_rr_post.png)  
[参考](https://blog.csdn.net/tanrui519521/article/details/80980135)  
### B+树
