---
layout: post
title:  C++编译
subtitle: C++编译、内存分配等
author: zql
date: 2020-04-24
catalog:  true
header-img: img/c++1.jpg
tags:
    - C++
---

### 目录
 - c++编译流程
 - 静态链接与动态链接
 - 头文件路径
 - 内存分配  

### c++编译流程  
对于C++源文件，从文本到可执行文件一般需要四个过程：  
**预处理阶段：**对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。  
**编译阶段：**将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。  
**汇编阶段：**将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。  
**链接阶段：**将多个目标文件及所需要的库连接成最终的可执行目标文件。  
### 静态链接与动态链接  
**静态链接**  
在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。  
假设生成hello可执行文件，需要根据在源文件中包含的头文件和程序中使用到的库函数，如stdio.h中定义的printf()函数，
在静态链接库libc.a中找到目标文件printf.o，然后将这个目标文件和hello.o这个文件进行链接形成我们的可执行文件。  
**静态链接优缺点**  
静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，
如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；
另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。  
但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。  
**动态链接**  
把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，
而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。下面简单介绍动态链接的过程：  
假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，
系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，
如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。
当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，
这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。  
**动态链接优缺点**  
动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。
当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。  
[参考1](https://blog.csdn.net/kang___xi/article/details/80210717)  
[参考2](https://www.cnblogs.com/52php/p/5681711.html)
### 头文件路径
Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。  
双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。  
对于使用双引号包含的头文件，查找头文件路径的顺序为：  
当前头文件目录。  
编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）。  
系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径。  
对于使用尖括号包含的头文件，查找头文件的路径顺序为：  
编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）。  
系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径。  
### 内存分配  
    ![avatar](/img/c++_memory.png)  
在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。  
**静态存储区：**  
**代码段：**包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。  
**数据段：**存储程序中已初始化的全局变量和静态变量。  
**bss段：**存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。  
**动态存储区：**  
**堆区：**调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。  
**映射区：**存储动态链接库以及调用mmap函数进行的文件映射。  
**栈：**使用栈空间存储函数的返回地址、参数、局部变量、返回值。  
### 未完待续
